import JSZip from 'jszip';

export const runtime = 'nodejs';

function csprojContent(): string {
  return `<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net48</TargetFramework>
    <LangVersion>latest</LangVersion>
    <Nullable>disable</Nullable>
    <AssemblyName>AnalyticalModelAddin</AssemblyName>
    <RootNamespace>AnalyticalModelAddin</RootNamespace>
    <Platforms>x64</Platforms>
  </PropertyGroup>
  <ItemGroup>
    <!-- Update HintPath to your installed Revit version if needed -->
    <Reference Include="RevitAPI">
      <HintPath>$(ProgramFiles)\\Autodesk\\Revit 2023\\RevitAPI.dll</HintPath>
      <Private>false</Private>
    </Reference>
    <Reference Include="RevitAPIUI">
      <HintPath>$(ProgramFiles)\\Autodesk\\Revit 2023\\RevitAPIUI.dll</HintPath>
      <Private>false</Private>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="WindowsBase" />
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
  </ItemGroup>
</Project>`;
}

function addinManifestContent(): string {
  return `<?xml version="1.0" encoding="utf-8" standalone="no"?>
<RevitAddIns>
  <AddIn Type="Command">
    <Name>AnalyticalModelAddin</Name>
    <Assembly>$(AppData)\\Autodesk\\Revit\\Addins\\2023\\AnalyticalModelAddin\\AnalyticalModelAddin.dll</Assembly>
    <AddInId>8D83FA04-944C-4F87-BE34-55C7E94C3B05</AddInId>
    <FullClassName>AnalyticalModelAddin.Command</FullClassName>
    <Text>Cr?er mod?le analytique</Text>
    <VendorId>AG82</VendorId>
    <VendorDescription>Generated by web app</VendorDescription>
  </AddIn>
</RevitAddIns>`;
}

function commandContent(): string {
  return `using System;
using System.Collections.Generic;
using Autodesk.Revit.Attributes;
using Autodesk.Revit.DB;
using Autodesk.Revit.DB.Structure;
using Autodesk.Revit.UI;

namespace AnalyticalModelAddin
{
  [Transaction(TransactionMode.Manual)]
  public class Command : IExternalCommand
  {
    public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements)
    {
      UIDocument uiDoc = commandData.Application.ActiveUIDocument;
      if (uiDoc == null)
      {
        message = "Ouvrez un projet Revit.";
        return Result.Failed;
      }
      Document doc = uiDoc.Document;

      try
      {
        using (Transaction tx = new Transaction(doc, "Cr?er mod?le analytique"))
        {
          tx.Start();

          // 1) Cr?er deux niveaux
          Level level0 = GetOrCreateLevel(doc, "Niveau 0", 0.0);
          Level level1 = GetOrCreateLevel(doc, "Niveau 1", 4000.0 / 304.8); // 4m en pieds
          Level level2 = GetOrCreateLevel(doc, "Niveau 2", 8000.0 / 304.8); // 8m en pieds

          // 2) Poteaux ? section variable (rectangulaire) via duplication de type
          IList<FamilySymbol> colSymbols = GetColumnSymbols(doc);
          if (colSymbols.Count > 0)
          {
            FamilySymbol baseSymbol = colSymbols[0];
            if (!baseSymbol.IsActive) baseSymbol.Activate();

            FamilySymbol typeSmall = DuplicateAndSetRectParams(baseSymbol, doc, "VarRect-300x300-400x400", 300, 300, 400, 400);
            FamilySymbol typeLarge = DuplicateAndSetRectParams(baseSymbol, doc, "VarRect-400x300-600x500", 400, 300, 600, 500);

            XYZ[] pts = new XYZ[] {
              new XYZ(0,0,0),
              new XYZ(6,0,0),
              new XYZ(0,6,0),
              new XYZ(6,6,0)
            };
            foreach (var p in pts)
            {
              // alterner les types
              var sym = ((int)(p.X + p.Y)) % 2 == 0 ? typeSmall : typeLarge;
              var col = doc.Create.NewFamilyInstance(p, sym, level0, StructuralType.Column) as FamilyInstance;
              col.get_Parameter(BuiltInParameter.FAMILY_TOP_LEVEL_PARAM).Set(level2.Id);
              col.get_Parameter(BuiltInParameter.FAMILY_BASE_LEVEL_PARAM).Set(level0.Id);
              col.get_Parameter(BuiltInParameter.FAMILY_BASE_LEVEL_OFFSET_PARAM).Set(0);
              col.get_Parameter(BuiltInParameter.FAMILY_TOP_LEVEL_OFFSET_PARAM).Set(0);
              StructuralSettingsToAnalytical(col);
            }
          }

          // 3) Voiles courbes (murs structurels) avec arcs
          WallType wallType = GetStructuralWallType(doc);
          if (wallType != null)
          {
            double r = 8.0; // pieds
            Arc arc1 = Arc.Create(new XYZ(-r, -r, 0), new XYZ(r, -r, 0), new XYZ(0, -r - r/2.0, 0));
            Arc arc2 = Arc.Create(new XYZ(-r, r, 0), new XYZ(r, r, 0), new XYZ(0, r + r/2.0, 0));
            CreateCurvedStructuralWall(doc, wallType, arc1, level0, level1);
            CreateCurvedStructuralWall(doc, wallType, arc2, level0, level2);
          }

          // 4) Coupoles (toits) ? d?me approxim? par RoofByFootPrint avec arcs (si type dispo)
          CreateDomeLikeRoof(doc, level2);

          // 5) Planchers structurels
          FloorType floorType = GetStructuralFloorType(doc);
          if (floorType != null)
          {
            CreateRectStructuralFloor(doc, floorType, level0, new XYZ(-4, -4, 0), new XYZ(4, 4, 0));
            CreateRectStructuralFloor(doc, floorType, level1, new XYZ(-3, -3, 0), new XYZ(3, 3, 0));
          }

          tx.Commit();
        }
      }
      catch (Exception ex)
      {
        message = ex.Message;
        return Result.Failed;
      }

      return Result.Succeeded;
    }

    private static Level GetOrCreateLevel(Document doc, string name, double elevation)
    {
      FilteredElementCollector col = new FilteredElementCollector(doc).OfClass(typeof(Level));
      foreach (Level l in col)
      {
        if (l.Name.Equals(name, StringComparison.OrdinalIgnoreCase))
          return l;
      }
      Level level = Level.Create(doc, elevation);
      level.Name = name;
      return level;
    }

    private static IList<FamilySymbol> GetColumnSymbols(Document doc)
    {
      IList<FamilySymbol> list = new List<FamilySymbol>();
      FilteredElementCollector col = new FilteredElementCollector(doc)
        .OfClass(typeof(FamilySymbol))
        .OfCategory(BuiltInCategory.OST_StructuralColumns);
      foreach (FamilySymbol s in col)
      {
        list.Add(s);
      }
      return list;
    }

    private static FamilySymbol DuplicateAndSetRectParams(FamilySymbol baseSymbol, Document doc, string newName, double bBaseMm, double hBaseMm, double bTopMm, double hTopMm)
    {
      FamilySymbol dup = baseSymbol.Duplicate(newName) as FamilySymbol;
      // Essaye des noms de param?tres courants
      SetIfExists(dup, "b", MmToFt(bBaseMm));
      SetIfExists(dup, "h", MmToFt(hBaseMm));
      SetIfExists(dup, "b1", MmToFt(bTopMm));
      SetIfExists(dup, "h1", MmToFt(hTopMm));
      return dup;
    }

    private static void SetIfExists(Element e, string paramName, double val)
    {
      Parameter p = e.LookupParameter(paramName);
      if (p != null && !p.IsReadOnly)
      {
        if (p.StorageType == StorageType.Double) p.Set(val);
      }
    }

    private static void StructuralSettingsToAnalytical(FamilyInstance inst)
    {
      try
      {
        inst.get_Parameter(BuiltInParameter.STRUCTURAL_MATERIAL_PARAM)?.Set(-1); // keep material as is
        // Analytical activ? par d?faut pour ?l?ments structurels
      }
      catch { }
    }

    private static WallType GetStructuralWallType(Document doc)
    {
      foreach (WallType wt in new FilteredElementCollector(doc).OfClass(typeof(WallType)))
      {
        if (wt.Kind != WallKind.Curtain && wt.Function == WallFunction.Structural)
          return wt;
      }
      // sinon, retourner n'importe quel type non rideau
      foreach (WallType wt in new FilteredElementCollector(doc).OfClass(typeof(WallType)))
      {
        if (wt.Kind != WallKind.Curtain) return wt;
      }
      return null;
    }

    private static void CreateCurvedStructuralWall(Document doc, WallType wt, Arc arc, Level baseLevel, Level topLevel)
    {
      double height = topLevel.Elevation - baseLevel.Elevation;
      Wall wall = Wall.Create(doc, arc, wt.Id, baseLevel.Id, height, 0, false, true);
      wall.get_Parameter(BuiltInParameter.WALL_STRUCTURAL_SIGNIFICANT)?.Set(1);
    }

    private static FloorType GetStructuralFloorType(Document doc)
    {
      foreach (FloorType ft in new FilteredElementCollector(doc).OfClass(typeof(FloorType)))
      {
        if (ft.get_Parameter(BuiltInParameter.FLOOR_PARAM_IS_STRUCTURAL)?.AsInteger() == 1)
          return ft;
      }
      foreach (FloorType ft in new FilteredElementCollector(doc).OfClass(typeof(FloorType)))
      {
        return ft;
      }
      return null;
    }

    private static void CreateRectStructuralFloor(Document doc, FloorType ft, Level level, XYZ min, XYZ max)
    {
      var p = new List<Curve>
      {
        Line.CreateBound(new XYZ(min.X, min.Y, 0), new XYZ(max.X, min.Y, 0)),
        Line.CreateBound(new XYZ(max.X, min.Y, 0), new XYZ(max.X, max.Y, 0)),
        Line.CreateBound(new XYZ(max.X, max.Y, 0), new XYZ(min.X, max.Y, 0)),
        Line.CreateBound(new XYZ(min.X, max.Y, 0), new XYZ(min.X, min.Y, 0))
      };
      CurveLoop loop = CurveLoop.Create(p);
      var loops = new List<CurveLoop> { loop };
      Floor floor = Floor.Create(doc, loops, ft.Id, level.Id);
      floor.get_Parameter(BuiltInParameter.FLOOR_PARAM_IS_STRUCTURAL)?.Set(1);
    }

    private static void CreateDomeLikeRoof(Document doc, Level level)
    {
      // Approche footprint circulaire + pente pour effet coupole
      RoofType roofType = null;
      foreach (RoofType rt in new FilteredElementCollector(doc).OfClass(typeof(RoofType)))
      {
        roofType = rt; break;
      }
      if (roofType == null) return;

      double r = 6.0;
      List<Curve> profile = new List<Curve>
      {
        Arc.Create(new XYZ(-r, 0, 0), new XYZ(r, 0, 0), new XYZ(0, r, 0)),
        Arc.Create(new XYZ(r, 0, 0), new XYZ(-r, 0, 0), new XYZ(0, -r, 0))
      };

      CurveArray footprint = new CurveArray();
      foreach (var c in profile) { footprint.Append(c); }

      // N?cessite un plan et un sketch; utiliser RoofByFootPrint si disponible
      SketchPlane sp = SketchPlane.Create(doc, Plane.CreateByNormalAndOrigin(XYZ.BasisZ, XYZ.Zero));
      ModelCurveArray curveArr = new ModelCurveArray();
      FootPrintRoof roof = doc.Create.NewFootPrintRoof(footprint, sp, level, roofType, out curveArr);
      foreach (ModelCurve mc in curveArr)
      {
        roof.set_DefinesSlope(mc, true);
        roof.set_SlopeAngle(mc, 0.6); // ~34?
      }
    }

    private static double MmToFt(double mm) => mm / 304.8;
  }
}
`;
}

function readmeContent(): string {
  return `# AnalyticalModelAddin

Add-in Revit qui cr?e un mod?le analytique comprenant:
- Poteaux ? section variable
- Voiles courbes (murs structurels)
- Coupole (toit par empreinte avec pente)
- Planchers structurels

Ouvrez la solution dans Visual Studio, corrigez les chemins RevitAPI si besoin, compilez et copiez le .addin dans le dossier Addins.
`;
}

export async function POST() {
  const zip = new JSZip();
  zip.file("AnalyticalModelAddin/AnalyticalModelAddin.csproj", csprojContent());
  zip.file("AnalyticalModelAddin/Command.cs", commandContent());
  zip.file("AnalyticalModelAddin/README.md", readmeContent());
  zip.file("AnalyticalModelAddin/AnalyticalModelAddin.addin", addinManifestContent());

  const buffer = await zip.generateAsync({ type: 'nodebuffer' });
  return new Response(buffer, {
    headers: {
      'Content-Type': 'application/zip',
      'Content-Disposition': 'attachment; filename="RevitAnalyticalModelAddin.zip"'
    }
  });
}

